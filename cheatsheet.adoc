= Design patterns
:experimental:
:source-highlighter: highlightjs
:source-language: cpp
:stylesheet: cheatsheet.css
:noheader:
:nofooter:


== Creational

=== Abstract factory

create different hierarchies
```
struct OrcFactory: ArmyFactory {
  Fighter* createFighter () override {
    return new OrcFighter;
  }
  Officer* createOfficer () override {
    return new OrcOfficer;
  }
}
```

=== Factory method

create single hierarchy
```
struct OrcBlacksmith : Blacksmith {
  Weapon* createWeapon (WeaponType) override;
}
```


=== Builder

create object from parts
```
struct OrcBuilder {
  void setWeapon (Weapon);
  void setArmor (Armor);
  Orc build ();
}
```

=== Step builder

wizard-like object creation
```
struct OrcStepBuilder : TypeStep, WeaponStep, BuildStep {
  WeaponStep* setType (Type) override; // TypeStep

  BuildStep* setWeapon (Type) override; // WeaponStep
  BuildStep* unarmed () override; // WeaponStep

  Orc build () override; // BuildStep
}
```

// === Factory kit ?

// === Lazy initialization ?

=== Multiton

limit object variety
```
struct District {
  static District& get (Name name) {
    static map<Name,District> districts;
    return districts[name];
  }
}
```

=== Object mother

create preset objects
```
struct OrcObjectMother {
  Orc* createAngry ();
  Orc* createScared ();
}
```

=== Object pool

store expensive objects
```
struct Armory {
  Weapon* acquire ();
  void release (Weapon* returned);
private:
  set<Weapon*> weapons;
  set<Weapon*> taken;
} 
```


=== Property

dynamic properties set
```
struct Orc : Prototype {
  bool set (Stat, Value) override;
  bool has (Stat) override;
  Value get (Stat) override;
  void remove (Stat) override;

  void waagh ();
private:
  map<Stat, Value> properties;
}

```


=== Prototype

only concrete instance knows its full state
```
struct Monster {
  virtual Monster* clone () = 0;
}
struct MonsterFactory {
  Monster* create (MonsterType type) {
    return prototypes[type]->clone ();
  }
private:
  map<MonsterType, Monster*> prototypes;
}
```


=== Resource acquisition is initialization (RAII)

prevent resource leaks
```
struct OrcShaman {
  OrcShaman () {
    ManaSource::addLeacher (this);
  }
  ~OrcShaman () {
    ManaSounrce::removeLeacher (this);
  }
}
```


=== Singleton

allow only one instance
```
struct EarthCore {
  static EarthCore& instance () {
    static EarthCore core;
    return core;
  }
private:
  EarthCore ();
}
```


=== MonoState

non global singleton replacement
```
struct Balancer {
  void serve (Request) {
    Server* server = nextServer ();
    server->serve (Request);
  }
private:
  int lastServed;
  list<Server*> servers;
}
```

// === Value object?



== Structural


=== Abstract document

dynamically manage properties
```
struct MonsterDocument {
  void set (Type, Value);
  Value get (Type);
private:
  map<Type, Value> properties;
}
struct Orc : MonsterDocument, HasWeapon {
  Weapon getWeapon () override { // HasWeapon
    return static_cast<Weapon>(get(Type::Weapon));
  }
}
```

=== Adapter

adapt foreign api
```
struct OrcMonsterAdapter : Monster, Orc {
  void attack () override {
    Orc::smash ();
  }
}
```

=== Bridge

ease separate changes of abstraction and implementation
```
struct Orc : Creature {
  void attackImpl () override;
}
struct Fighter : Monster {
  Fighter (Creature* impl);
  void attack () override {
    impl->attackImpl ();
  }
}
```


=== Composite

treat composite object same way as single
```
struct Kingdom : Area {
  double square () override {
    return accumulate (children, Area::square);
  }
  void addArea (Area*) override;
private:
  list<Area*> children;
}
kingdom.addArea (new NothernRealm);
```

=== Decorator

dynamically add/remove behavior to object
```
struct WallsDecorator : public Town {
  WallsDecorator (Town* decorated);
  int strength () override {
    return decorated->strength () + 10;
  }
}
Town* castle = new WallsDecorator (new Town ());
```

=== Event aggregator

gather all events in one place
```
struct Aggregator {
  void registerSubscriber (Subscriber);
  void publish (Event event) {
    for_each (subscribers, Subscriber::handle (event));
  }
}
```

=== Extension object

provide additional interface to object without changing hierarchy
```
struct Kingdom {
  Kingdom (Capital*);
  Capital* getCapitalExtension ();
}
Kingdom kingdom (new GuardedCapital);
```

=== Facade

single interface for several subsystems
```
struct Army {
  void attack () {
    officers->makeOrders ();
    fighters->followOrders ();
    shamans->prey ();
  }
}
```

=== Flyweight

many similar objects with shared state
```
struct Forge {
  Weapon craft (Type type) {
    return Weapon (stats[type]);
  }
private:
  map<Type, WeaponStats*> stats;
}
```

=== Front controller

handle all requests in one place
```
struct Controller {
  void handle (Request request) {
    getProcessor ().process (request);
  }
}
```

=== Marker

indicate class behaviour
```
struct Orc : Agressive {
}
if (dynamic_cast<Agressive*>(monster)) monster->attack ();
```

=== Module

group connected functions
```
struct ConsoleModule {
  void prepare ();
  void unprepare ();
  static ConsoleModule& instance ();
  void print (variant);
  variant scan ();
}
```

=== Proxy

add functionality to interface
```
struct GuardedArmory : Armory {
  void enter (Monster monster) override {
    if (looksLikeOrc (monster)) armory->enter (monster);
    else logFailure (monster);
  }
private:
  Armory *armory;
}
```

=== Service locator

ease and cache service discovery
```
struct OrcIntelligence {
  static Area locate (Faction faction) {
    if (!cache.contains (faction)) {
      cache[faction] = lookFor (faction);
    }
    return cache[faction];
  }
private:
  LastSeen<Faction, Area> cache;
}
```


== Behavioral


=== Blackboard

integrate many modules in complex strategy
```
struct IntelligenceControl {
  void updateDisposition () {
    for_each (scouts, KnowledgeSource::updateBlackboard (worldMap));
    correctConflicts (worldMap);
    killLiars (scoutsAndShamans);
  }
private:
  Blackboard worldMap;
  list<KnowledgeSource*> scoutsAndShamans;
}
```

=== Chain of responsibility

concrete unknown handler for concrete request
```
struct OrcFighter : RequestHandler {
  void handle (Request request) override {
    if (request.type == Type::Attack) {
      attack ();
      if (++request.attackers > 10) return;
    }
    RequestHandler::nextHandler ()->handle (request);
  }
}
```

=== Command

hold all required data to perform/abort event
```
struct MoveArmy : Command {
  MoveArmy (Area from, Area to);
  void execute () override {
    from.removeArmy (this);
    to.addArmy (this);
  }
}
```

=== Delegation

provide functionality via composite part
```
struct OrcFighter {
  Size weaponSize () constq {
    return weapon.size ();
  }
}
```

=== Dependency injection

get constructed dependency instead of create by self
```
struct OrcFighter {
  OrcFighter (AbstractArmor* armor);
  void hit (Damage damage) {
    health -= armor->reduceDamage (damage);
  }
}
```

=== Feature toggle

dynamically enable/disable code branches
```
struct OrcFighter {
  void attack () {
    if (FeatureManager::isEnabled (Sound)) {
      attackWithRoar ();
    }
    else {
      simpleAttack ();
    }
    if (weapon.isOneHanded ()) {
      taunt ();
    }
  }
}
```

=== Intercepting filter

add pre/post-processing to requests
```
struct OrcFighter : Filter {
  void execute (Command letter) override {
    laughtLoudly (command);
  }
}
struct FilterManager {
  FilterManager (Target target);
  void execute (Command letter) {
    for_each (filters, Filter::execute (letter));
    target.deliver (letter);
  }
private:
  list<Filter*> filters;
}
```

=== Interpreter

handle asbtract syntax tree of domain specific language
```
struct Plus : Expression {
  Plus (Expression& left, Expression& right);
  Value interpret () override {
    return left.interpret () + right.interpret ();
  }
}
```

=== Iterator

traverse container without knowing its structure
```
struct OrcIterator : Iterator {
  OrcIterator (OrcArmy::fighters* firstOrc) : currentOrc (firstOrc);
  Iterator& operator++ () { // next
    ++currentOrc;
    return *this;
  };
  Iterator& operator-- (); // previous
  Orc& operator* (); // current value
  bool operator== ();
}
```

=== Mediator

hide objects interacion details
```
struct OrcTrainingCamp {
  void train (Orc& trainer, Orc& apprentice) {
    if (trainer.isShaman () && apprentice.isShaman ()) {
      apprentice.raiseSkill (trainer.skill ());
    }
    ...
  }
}
```

=== Memento

save/restore object's state
```
struct Orc {
  Memento state () { return Memento {this->health}; }
  void restore (Memento memento) { this->health = memento.health; }

  class Memento {
    int health;
    friend class Orc;
  }
}
```

=== Null object

specific object for empty (null) behaviour
```
struct FakeOrc : Orc {
  void attack () override {}
}
Orc* makeNewOrc () {
  if (!reachedLimit ()) return new Orc;
  return new FakeOrc;
}
```

=== Observer

notify subscribers about publisher events
```
struct CastleObserver : Observer {
  void addSubscriber (Orc& subscriber);
  void notify (Event& event) override {
    for_each (subscribers, Orc::handle (event));
  }
}

struct Castle : Observable {
  void addObserver (Observer) override;
  void openDoors () {
    DoorOpenEvent event;
    for_each (observers, Observer::notify (event));
  }
}
```

=== Servant

add behaviour to other classes
```
struct Blacksmith {
  void sharpenWeapon (Fighter*);
}
```

=== Specification

filter of validate objects with dynamic rules
```
struct SkillCheck : Specification {
  bool check (Orc& orc) override {
    return skill > 10;
  }
}
struct HealthCheck : Specification {
  bool check (Orc& orc) override {
    return health > 90;
  }
}
void recruitCandidate (Orc& orc) {
  AndSpecification complex = SkillCheck ().and (HealthCheck());
  if (complex.check (orc)) {
    assignForImportantMission (orc);
  }
}
```

=== State

change behaviour by switching between object's internal states
```
struct Orc {
  void hit (Damage damage) {
    health -= damage;
    if (health < 10) setState (new ScaredState);
  }
  void attack () {
    state->attack ();
  }
}
struct ScaredState : State {
  void attack () override {
    owner->flee ();
  }
}
```

=== Strategy

use group of interchangeable algorithms
```
struct Orc {
  void attack () {strategy->attack ();}
private:
  AttackStrategy* strategy;
}
```

=== Template method

redefine parts of algorithms in subclasses
```
struct Orc {
  Target* chooseTarget ();
  virtual hitTarget () = 0;
  void stepBack ();

  void attack () {
    auto target = chooseTarget ();
    hitTarget (target);
    stepBack ();
  }
}
```

=== Visitor

apply operation on structure's elements with different interfaces
```
struct ArmyMeleeSkill : Visitor {
  void visit (Fighter& fighter) override {
    skill += fighter.skill ();
  }
  void visit (Shaman& shaman) override {
  }
}
struct Fighter : Visitable {
  void accept (Visitor& visitor) override {
    visitor.visit (*this);
  }
}
```
