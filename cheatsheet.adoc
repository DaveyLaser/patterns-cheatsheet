= Design patterns
:experimental:
:source-highlighter: highlightjs
:source-language: cpp
:stylesheet: cheatsheet.css
:noheader:
:nofooter:


== Creational

=== Abstract factory

create different hierarchies
```
struct OrcFactory: ArmyFactory {
  Fighter* createFighter () override {
    return new OrcFighter;
  }
  Officer* createOfficer () override {
    return new OrcOfficer;
  }
}
```

=== Factory method

create single hierarchy
```
struct OrcBlacksmith : Blacksmith {
  Weapon* createWeapon (WeaponType) override;
}
```


=== Builder

create object from parts
```
struct OrcBuilder {
  void setWeapon (Weapon);
  void setArmor (Armor);
  Orc build ();
}
```

=== Step builder

wizard-like object creation
```
struct OrcStepBuilder : TypeStep, WeaponStep, BuildStep {
  WeaponStep* setType (Type) override; // TypeStep

  BuildStep* setWeapon (Type) override; // WeaponStep
  BuildStep* unarmed () override; // WeaponStep

  Orc build () override; // BuildStep
}
```

// === Factory kit ?

// === Lazy initialization ?

=== Multiton

limit object variety
```
struct District {
  static District& get (Name name) {
    static map<Name,District> districts;
    return districts[name];
  }
}
```

=== Object mother

create preset objects
```
struct OrcObjectMother {
  Orc* createAngry ();
  Orc* createScared ();
}
```

=== Object pool

store expensive objects
```
struct Armory {
  Weapon* acquire ();
  void release (Weapon* returned);
private:
  set<Weapon*> weapons;
  set<Weapon*> taken;
} 
```


=== Property

dynamic properties set
```
struct Orc : Prototype {
  bool set (Stat, Value) override;
  bool has (Stat) override;
  Value get (Stat) override;
  void remove (Stat) override;

  void waagh ();
private:
  map<Stat, Value> properties;
}

```


=== Prototype

only concrete instance knows its full state
```
struct Monster {
  virtual Monster* clone () = 0;
}
struct MonsterFactory {
  Monster* create (MonsterType type) {
    return prototypes[type]->clone ();
  }
private:
  map<MonsterType, Monster*> prototypes;
}
```


=== Resource acquisition is initialization (RAII)

prevent resource leaks
```
struct OrcShaman {
  OrcShaman () {
    ManaSource::addLeacher (this);
  }
  ~OrcShaman () {
    ManaSounrce::removeLeacher (this);
  }
}
```


=== Singleton

allow only one instance
```
struct EarthCore {
  static EarthCore& instance () {
    static EarthCore core;
    return core;
  }
private:
  EarthCore ();
}
```


=== MonoState

non global singleton replacement
```
struct Balancer {
  void serve (Request) {
    Server* server = nextServer ();
    server->serve (Request);
  }
private:
  int lastServed;
  list<Server*> servers;
}
```

// === Value object?



== Structural


=== Abstract document

dynamically manage properties
```
struct MonsterDocument {
  void set (Type, Value);
  Value get (Type);
private:
  map<Type, Value> properties;
}
struct Orc : MonsterDocument, HasWeapon {
  Weapon getWeapon () override { // HasWeapon
    return static_cast<Weapon>(get(Type::Weapon));
  }
}
```

=== Adapter

adapt foreign api
```
struct OrcMonsterAdapter : Monster, Orc {
  void attack () override {
    Orc::smash ();
  }
}
```

=== Bridge

ease separate changes of abstraction and implementation
```
struct Orc : Creature {
  void attackImpl () override;
}
struct Fighter : Monster {
  Fighter (Creature* impl);
  void attack () override {
    impl->attackImpl ();
  }
}
```


=== Composite

treat composite object same way as single
```
struct Kingdom : Area {
  double square () override {
    return accumulate (children, Area::square);
  }
  void addArea (Area*) override;
private:
  list<Area*> children;
}
kingdom.addArea (new NothernRealm);
```

=== Decorator

dynamically add/remove behavior to object
```
struct WallsDecorator : public Town {
  WallsDecorator (Town* decorated);
  int strength () override {
    return decorated->strength () + 10;
  }
}
Town* castle = new WallsDecorator (new Town ());
```

=== Event aggregator

gather all events in one place
```
struct Aggregator {
  void registerSubscriber (Subscriber);
  void publish (Event event) {
    for_each (subscribers, Subscriber::handle (event));
  }
}
```

=== Extension object

provide additional interface to object without changing hierarchy
```
struct Kingdom {
  Kingdom (Capital*);
  Capital* getCapitalExtension ();
}
Kingdom kingdom (new GuardedCapital);
```

=== Facade

single interface for several subsystems
```
struct Army {
  void attack () {
    officers->makeOrders ();
    fighters->followOrders ();
    shamans->prey ();
  }
}
```

=== Flyweight

many similar objects with shared state
```
struct Forge {
  Weapon craft (Type type) {
    return Weapon (stats[type]);
  }
private:
  map<Type, WeaponStats*> stats;
}
```

=== Front controller

handle all requests in one place
```
struct Controller {
  void handle (Request request) {
    getProcessor ().process (request);
  }
}
```

=== Marker

indicate class behaviour
```
struct Orc : Agressive {
}
if (dynamic_cast<Agressive*>(monster)) monster->attack ();
```

=== Module

group connected functions
```
struct ConsoleModule {
  void prepare ();
  void unprepare ();
  static ConsoleModule& instance ();
  void print (variant);
  variant scan ();
}
```

=== Proxy

add functionality to interface
```
struct GuardedArmory : Armory {
  void enter (Monster monster) override {
    if (looksLikeOrc (monster)) armory->enter (monster);
    else logFailure (monster);
  }
private:
  Armory *armory;
}
```

=== Servant

add behaviour to other classes
```
struct Blacksmith {
  void sharpenWeapon (Fighter*);
}
```

=== Service locator

ease and cache service discovery
```
struct OrcIntelligence {
  static Area locate (Faction faction) {
    if (!cache.contains (faction)) {
      cache[faction] = lookFor (faction);
    }
    return cache[faction];
  }
private:
  LastSeen<Faction, Area> cache;
}
```


== Behavioral
